# Лабораторная работа №2. Ручное построение нисходящих синтаксических анализаторов
## Вариант 2. Регулярные выражения
Регулярные выражения с операциями конкатенации (простая последовательная запись строк), выбора (вертикальная черта), замыкания Клини. Приоритет операций стандартный. Скобки могут использоваться для изменения приоритета. Для обозначения базовых языков используются маленькие буквы латинского алфавита. Используйте один терминал для всех символов.

_Пример:_ `((abc*b|a)*ab(aa|b*)b)*`
### Разработка [КС-грамматики](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%BD%D0%BE-%D1%81%D0%B2%D0%BE%D0%B1%D0%BE%D0%B4%D0%BD%D1%8B%D0%B5_%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B8,_%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4,_%D0%BB%D0%B5%D0%B2%D0%BE-_%D0%B8_%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%81%D1%82%D0%BE%D1%80%D0%BE%D0%BD%D0%BD%D0%B8%D0%B9_%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4,_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D1%80%D0%B0%D0%B7%D0%B1%D0%BE%D1%80%D0%B0)
Сначала разработаем грамматику, исходя из структуры языка, чтобы она максимально близко соответствовала интуитивным представлениям о построении слов из языка.

Наши операции обладают следующими приоритетами:

| Приоритет | Операция        | Обозначение |
|-----------|-----------------|-------------|
| `0`       | Выбора          | `a\|b`      |
| `1`       | Конкатенации    | `ab`        |
| `2`       | Замыкания Клини | `a*`        |
| `3`       | Взятия в скобки | `(RE)`      |

Учитывая приоритеты строим КС-грамматику:

| Операция      | Переход                 |
|---------------|-------------------------|
| Select        | `S -> S\|C` \| `C`       |
| Concatenation | `С -> CC` \| `K`        |
| Kleene        | `K -> K*` \| `R`        |
| Regex         | `R -> (S)` \| `[a..z]`  |

Поскольку для нисходящего парсераТерминалами в нашей грамматике являются маленькие буквы латинского алфавита, скобки и символы операторов. нужна [LL(1)-грамматика](https://neerc.ifmo.ru/wiki/index.php?title=LL(k)-%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B8,_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B0_FIRST_%D0%B8_FOLLOW). Текущая грамматика имеет левую рекурсию и правое ветвление, а значит не является LL(1)-грамматикой. Устраним [левую рекурсию](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A3%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BB%D0%B5%D0%B2%D0%BE%D0%B9_%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B8) и [правое ветвление](https://neerc.ifmo.ru/wiki/index.php?title=LL(k)-%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B8,_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B0_FIRST_%D0%B8_FOLLOW):

| Переход               | Описание                              |
|-----------------------|---------------------------------------|
| `S -> CS"`            | Выбор и продолжение                   |
| `S" -> \|CS"` \| `ε`  | Продолжение или пустая строка         |
| `C -> KC"`            | Композиция и продолжение              |
| `C" -> KC"` \| `ε`    | Композиция или пустая строка          |
| `K -> RK"`            | Замыкание и продолжение               |
| `K" -> *K"` \| `ε`    | Замыкание или пустая строка           |
| `R -> (S)` \| `[a..z]`| Regex в скобках или латинские буквы   |

###  Построение лексического анализатора
Терминалы и соответствующие им токены в нашей грамматике:

| Терминал | Токен      |
|----------|------------|
| `(`      | `LPAREN`   |
| `)`      | `RPAREN`   |
| `\|`      | `SELECT`   |
| `*`      | `KLEENE`   |
| `[a..z]` | `LETTER`   |
| `$`      | `END`      |

### Построение синтаксического анализатора
[Построим множества FIRST и FOLLOW](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5_FIRST_%D0%B8_FOLLOW) для нетерминалов нашей грамматики:

| Нетерминал | *FIRST*          | *FOLLOW*                          |
|------------|------------------|-----------------------------------|
| `S`        | `(`, `a..z`      | `)`, `$`                          |
| `S"`       | `\|`, `ε`         | `)`, `$`                          |
| `C`        | `(`, `a..z`      | `)`, `\|`, `$`                     |
| `C"`       | `(`, `a..z`, `ε` | `)`, `\|`, `$`                     |
| `K`        | `(`, `a..z`      | `(`, `)`, `\|`, `a..z`, `$`        |
| `K"`       | `*`, `ε`         | `(`, `)`, `\|`, `a..z`, `$`        |
| `R`        | `(`, `a..z`      | `(`, `)`, `\|`, `*`, `a..z`, `$`   |

###  Визуализация дерева разбора
Для визуализации дерева разбора используем систему [GraphViz](https://graphviz.org/).
###  Тесты
Пример работы можно увидеть в [тестах](src/test/java/Tests.kt) основанных на JUnit4, а также проверить при запуске [Main.kt](src/main/java/Main.kt) на своей строке для парсинга.
